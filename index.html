<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GMTK 2021</title>
  </head>
  <script>
    var loadedImgs = 0;
    function imageLoaded() {
      loadedImgs++;
    }
  </script>
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 0;
      background-color: darkgray;
      min-height: 100vh;
      font-family: Arial, Helvetica, sans-serif;
    }

    button {
      padding: 5px 10px;
      background-color: teal;
      color: white;
      border-radius: 3px;
      box-shadow: 3px 5px 5px rgba(0, 0, 0, 0.658);
      cursor: pointer;
    }

    button:active {
      box-shadow: inset 1px 1px 10px #333;
    }

    #canvas {
      width: 100vmin;
      height: 100vmin;
      background-color: rgb(255, 192, 203);
    }
    .goingUp {
      position: absolute;
      display: block;
      left: 0;
      right: 0;
      margin-left: auto;
      margin-right: auto;
      width: 500px;
      background-color: rgba(128, 128, 128, 0.445);
      padding: 20px;
      display: flex;
      flex-flow: column nowrap;
      justify-content: center;
      align-items: center;
    }
    .btn-group {
      display: flex;
      flex-direction: row;
      justify-content: space-evenly;
      gap: 2rem;
    }
    .hidden {
      display: none;
    }

    h2 {
      color: white;
    }
  </style>
  <body>
    <div id="startScreen">
      <h2>Press Start to Play!</h2>
      <button id="playBtn" onclick="startGame()" disabled>Start!</button>
      <button id="settingsBtn" onclick="goToSettings()">Settings</button>
    </div>
    <div id="settingsScreen" class="hidden">
      <select id="difficulty">
        <option value="0" selected>Easy</option>
        <option value="1">Medium</option>
        <option value="2">Hard</option>
      </select>
      <button id="menuBtn" onclick="goToMenu()">Back</button>
    </div>
    <div class="hidden goingUp" id="goingUp">
      <h2>Going Up?</h2>
      <div class="btn-group">
        <button id="goUpButton" onclick="goUp()">Up!</button>
        <button id="goDownButton" onclick="goDown()">Nope!</button>
      </div>
    </div>
    <canvas id="canvas" class="hidden" width="1000" height="1000">Your browser doesn't support html5 canvas!</canvas>
    <canvas hidden id="renderer" width="1000" height="1000"></canvas>
    <canvas hidden id="mapLoader" width="1000" height="2500"></canvas>

    <!-- assets -->
    <img src="./assets/filler-underwater-background.jpg" id="backgroundpic" hidden />
    <img src="./assets/lvl1.png" id="c_map" onload="imageLoaded()" hidden />
    <audio id="menuTune" preload="auto" src="./assets/menu_concept_1.mp3" type="audio/mpeg">Your browser does not support the audio element</audio>
  </body>
</html>

<!-- Scripts -->
<script src="camera.js"></script>
<script src="particles.js"></script>
<script src="collisionMap.js"></script>
<script src="treasure.js"></script>
<script src="diver.js"></script>
<script src="submarine.js"></script>
<script>
  const canvas = document.getElementById("canvas");
  const renderer = document.getElementById("renderer");
  const vis_ctx = canvas.getContext("2d");
  const ctx = renderer.getContext("2d");

  const SIZE = 1000;
  const MAP_H = 2500;
  const keys = {};
  var subLives;
  var diveLives;
  var hitGrace;
  var points;
  var subTimeRemaining;
  var diveTimeRemaining;
  var dead;
  var map_data;
  var paused;
  var difficultyLevel;
  // var isGoingDown = true;
  const TILES = {
    "255,174,201,255": null,
    "255,255,255,255": 0,
    "0,0,0,255": 1,
  };
  let done = false;

  // inits
  let submarine = new Submarine();
  let diver = new Diver();
  let camera = new Camera();
  let particles = new Particles();
  // level 1 chests
  // let chests = [new Treasure(500, 500, 10), new Treasure(500, 100, 1)];
  let chests = [
    new Treasure(300, 356, 2),
    new Treasure(636, 524, 2),
    new Treasure(906, 860, 3),
    new Treasure(294, 734, 3),
    new Treasure(182, 1070, 5),
    new Treasure(591, 1004, 5),
    new Treasure(717, 1313, 7),
    new Treasure(198, 1345, 7),
    new Treasure(510, 2068, 9),
    new Treasure(705, 2438, 10),
  ];

  function goToSettings() {
    startScreen.classList.add("hidden");
    settingsScreen.classList.remove("hidden");
  }
  function goToMenu() {
    startScreen.classList.remove("hidden");
    settingsScreen.classList.add("hidden");
    canvas.classList.add("hidden");
  }

  function startGame() {
    updateDifficulty();
    canvas.classList.remove("hidden");
    startScreen.classList.add("hidden");
    done = false;
    // RESET GAME HERE
    console.log("starting");
    subLives = 3;
    diveLives = 3;
    hitGrace = 0;
    points = 0;
    subTimeRemaining = 60;
    diveTimeRemaining = 10;
    dead = false;
    submarine.reset(500, 50);
    diver.reset(500, 0);
    submarine.isGoingDown = true;
    camera.x = 0;
    camera.y = 0;
    // playAudio();
    paused = false;
    tick();
  }

  function updateDifficulty() {
    var chosenDifficultyLevel = document.getElementById("difficulty");
    difficultyLevel = chosenDifficultyLevel.options[chosenDifficultyLevel.selectedIndex].value;
  }

  function playAudio() {
    var audio = document.getElementById("menuTune");
    audio.currentTime = 0;
    audio.play();
  }

  function initMap() {
    if (loadedImgs == 1) {
      const mlctx = mapLoader.getContext("2d");
      mlctx.drawImage(c_map, 0, 0);
      map_data = getCanvasData(mlctx);
      flushToCanvas();
      clearInterval(mapInitInterval);
      playBtn.disabled = false;
    }
  }
  let mapInitInterval = setInterval(initMap, 500);

  function tick() {
    update();
    draw();
    if (!done) {
      requestAnimationFrame(tick);
    }
  }

  // reduce the time
  function countDownSeconds() {
    if (diver.isOutOfSub == true) {
      diveTimeRemaining = diveTimeRemaining - 1 / 60;
    } else {
      diveTimeRemaining = 10;
      subTimeRemaining = subTimeRemaining - 1 / 60;
    }
    deathByTime();
  }

  // when you run out of time
  function deathByTime() {
    if (subTimeRemaining <= 0 || diveTimeRemaining <= 0) {
      console.log("YOU DIED");
      dead = true;
    }
  }

  //when you run out of lives
  function deathByBlows() {
    if (subLives == 0 || diveLives == 0) {
      console.log("YOU DIED");
      dead = true;
    }
  }

  function reduceHealth() {
    if (hitGrace == 0 && submarine.takingDamage) {
      subLives = subLives - difficultyLevel;
      hitGrace = hitGrace + 0.5;
      var hitTimer = setTimeout(updateHitGrace, 1000);
      deathByBlows();
    }
  }

  //determine how soon health can be reduced again
  function updateHitGrace() {
    hitGrace = hitGrace - 0.5;
  }

  function increasePoints(amt) {
    if (diver.isOutOfSub) {
      points += amt;
    }
  }

  function draw() {
    ctx.clearRect(0, 0, SIZE, SIZE);
    ctx.save();

    const cameraBase = (camera.y / 10) % MAP_H;
    // ctx.drawImage(backgroundpic, 0, cameraBase, SIZE, MAP_H);
    // ctx.drawImage(backgroundpic, 0, 0 + SIZE, SIZE, SIZE);
    ctx.translate(camera.x, camera.y);
    ctx.drawImage(c_map, 0, 0, SIZE, MAP_H);

    // HUD
    ctx.font = "italic 18px Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "red";
    ctx.fillText("Sub Lives Left: " + subLives, 30, 25 - camera.y);
    ctx.fillText("Dive Lives Left: " + diveLives, 30, 50 - camera.y);
    ctx.fillText("Treasure Points: " + points, 30, 75 - camera.y);
    ctx.fillText("Sub Time Remaining: " + subTimeRemaining.toFixed(0), 500, 25 - camera.y);
    ctx.fillText("Dive Time Remaining: " + diveTimeRemaining.toFixed(0), 500, 50 - camera.y);

    submarine.draw(ctx);
    diver.draw(ctx);
    particles.draw(ctx);
    chests.forEach((chest, idx) => chest.draw(ctx));

    ctx.fillRect(cursor.x, cursor.y, 10, 10);

    ctx.restore();

    ctx.fillText(submarine.vy, 10, 100);
    ctx.fillText(submarine.y, 10, 150);
  }

  function update() {
    if (!paused) {
      submarine.update(keys);
      diver.update(keys);
      camera.update();
      particles.update();
      countDownSeconds();
      reduceHealth();

      chests.forEach((chest, idx) => {
        chest.update();
        if (diver.isOutOfSub && circlesCollide(diver.cx, diver.cy, diver.h / 2, chest.x, chest.y, chest.r)) {
          console.log("got it!!");
          increasePoints(chest.loot);
          chests.splice(idx, 1);
        }
      });

      //placeholder for colliding and reducing health
      if (keys["g"]) {
        reduceHealth();
      }
      //placeholder for collecting treasure
      if (keys["c"]) {
        increasePoints();
      }
      // end game
      if (keys["Escape"] || dead || submarine.y <= 0) {
        done = true;
        goToMenu();
      }
      //trigger switch prompt
      if (keys["q"] && submarine.isGoingDown) {
        switchDirectionsPrompt();
        keys["q"] = false;
      }
    }
  }

  function switchDirectionsPrompt() {
    goingUp.classList.remove("hidden");
    paused = true;
  }
  function goUp() {
    submarine.isGoingDown = false;
    goingUp.classList.add("hidden");
    paused = false;
  }
  function goDown() {
    submarine.isGoingDown = true;
    goingUp.classList.add("hidden");
    paused = false;
  }

  function circlesCollide(x1, y1, r1, x2, y2, r2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    const dsq = dx * dx + dy * dy;
    const rsq = (r1 + r2) * (r1 + r2);
    return dsq < rsq;
  }

  window.onkeydown = function (event) {
    const k = event.key;
    keys[k] = true;
  };
  window.onkeyup = function (event) {
    const k = event.key;
    keys[k] = false;
  };

  window.cursor = {
    x: 0,
    y: 0,
  };
  canvas.addEventListener("mousemove", (e) => {
    cursor.x = Math.round((e.offsetX * canvas.width) / canvas.clientWidth);
    cursor.y = Math.round((e.offsetY * canvas.height) / canvas.clientHeight);
  });
</script>
